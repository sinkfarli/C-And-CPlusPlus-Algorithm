# 线性表（Linear List）
Author & Note ：影风远sinkfarli

Create Date ：2022.6.9

## 什么是线性表？
首先应该介绍线性表的逻辑结构定义。从逻辑上来看，线性表就是由n（n≥0）个数据元素a1，a2，…，an组成的有限序列。这里需要做如下几点说明：
- 数据元素的个数为n，也称为表的长度，当n=0时称为空表。
- 如果一个线性表非空，也就是n>0，则可以简单地记作（a1，a2，……，an）。
- 数据元素ai（1≤i≤n）表示各个元素，不同的场合，其含义也不尽相同。

在现实生活中，我们可以找到很多线性表的例子。例如，英文字母表就是最简单的线性表，英文字母表（A，B，C，…，Z）中，每个英文字符就是一个数据元素，也称为数据结点。另外，如表2-1所示的某班级学生成绩表也是一个线性表，其中的数据元素就是某个学生的记录，包括学号、姓名、各个科目的成绩等。

对于一个非空的线性表，具有如下所示的逻辑结构特征：
- 有且仅有一个开始结点a1，没有直接前趋结点，有且仅有一个直接后继结点a2。
- 有且仅有一个终结结点an，没有直接后继结点，有且仅有一个直接前趋结点an-1。
- 其余的内部结点ai（2≤i≤n-1）都有且仅有一个直接前趋结点ai-1和一个直接后继结点ai+1。

对于同一线性表，各数据元素ai必须具有相同的数据类型，即同一线性表中各数据元素具有相同的类型，每个数据元素的长度相同。

## 线性表的基本运算
1. 初始化
   初始化表（InitList）也就是构造一个空的线性表L。
2. 计算表长
   计算表长（ListLength）也就是计算线性表L中结点的个数。
3. 获取结点
   获取结点（GetNode）就是取出线性表L中第i个结点的数据，这里1 ≤ i ≤ ListLength（L）。
4. 查找结点
   查找结点（LocateNode）就是在线性表L中查找值为x的结点，并返回该结点在线性表L中的位置。如果在线性表中没有找到值为x的结点，则返回一个错误标志。这里需要注意的是，线性表中有可能含有多个与x值相同的结点，那么这时就只返回第一次查找到的结点。
5. 插入结点
   插入结点（InsertList）就是在线性表L的第i个位置上插入一个新的结点，使得其后的结点编号依次加1。这时，插入1个新结点之后，线性表L的长度将变为n+1。
6. 删除结点
   删除结点（DeleteList）就是删除线性表L中的第i个结点，使得其后的所有结点编号依次减1。这时，删除1个结点之后，线性表L的长度将变为n-1。

## 线性表存储方式
### 顺序表结构
顺序存储结构的线性表称为顺序表(Sequential List)

按照顺序存储方式存储的线性表，该线性表的结点按照逻辑次序依次存放在计算机的**一组连续**的存储单元中。

由于顺序表是依次存放的，只要知道了该顺序表的首地址以及每个数据元素所占用的存储长度，很容易计算出任何一个数据元素（也就是数据结点）的位置。

假设顺序表中所有结点的类型相同，则每个结点所占用存储空间的大小亦相同，每个结点占用c个存储单元。其中第1个单元的存储地址则是该结点的存储地址，并设顺序表中开始结点a1的存储地址（简称为基地址）是LOC（a1），那么结点ai的存储地址LOC（ai）可通过下式计算得到。
$$LOC（ai）=LOC（a1）+（i-1）*c　  1≤i≤n$$

C语言编写步骤（也是基本框架），相关代码在对应的文件：
1. 准备数据
2. 初始化顺序表
3. 计算顺序表长度
4. 插入节点
5. 追加节点
6. 查找节点
   1. 按照序号查找节点
   2. 按照关键字查找节点
7. 显示所有节点

顺序表结构的缺点：
- 在插入或者删除结点时，往往需要移动大量的数据。
- 如果表比较大，有时难以分配足够的连续存储空间，往往导致内存分配失败，而无法存储。

### 链表结构
链式存储的线性表称为链表(linked list)。

链表结构是一种动态存储分配的结构形式，可以根据需要动态申请所需的内存单元。

#### 什么是链表结构？
链表中每个节点都包括如下两部分：
- 数据部分：保存的是该结点的实际数据。
- 地址部分：保存的是下一个结点的地址。

链表结构是由许多结点构成的。在进行链表操作时，首先需要定义1个“头指针”变量（一般以head表示），该指针变量指向链表结构的第一个结点，第1个结点的地址部分又指向第2个结点……直到最后一个结点。最后一个结点不再指向其他结点，称为“表尾”，一般在表尾的地址部分放一个空地址NULL，链表到此结束。从链表结构图可以看出，整个存储过程十分类似于一条长链，因此形象地称为链表结构，或者链式结构。

采用了指针来指示下一个数据的地址，因此在链表结构中，逻辑上相邻的结点在物理内存中并不一定相邻，逻辑相邻关系通过地址部分的指针变量来实现。

链表结构也有缺点，那就是浪费存储空间。对于每个结点数据，都要额外保存一个指针变量。但是在某些场合，链表结构所带来的好处还是大于其缺点的。

对于链表的访问只能从表头逐个查找，即通过head头指针找到第1个结点，再从第1个结点找到第2个结点……这样逐个比较一直到找到需要的结点为止，而不能像顺序表那样进行随机访问。

链式存储是最常用的存储方式之一，不仅可用来表示线性表，而且可用来表示各种非线性的数据结构。链表结构还可以细分为如下几类：
- 单链表：向上面的链式结构一样，每个结点中只包含一个指针。
- 双向链表：若每个结点包含两个指针，一个指向下一个结点，另一个指向上一个结点，这就是双向链表。
- 单循环链表：在单链表中，将终端结点的指针域NULL改为指向表头结点或开始结点即可构成单循环链表。
- 多重链的循环链表：如果将表中结点链在多个环上，将构成多重链的循环链表。

C语言编写步骤（也是基本框架），相关代码在对应的文件：
1. 准备数据
   首先需要准备数据，也就是准备在链表操作中需要用到的变量及数据结构等。
2. 追加结点
   - 追加结点就是在链表末尾增加一个结点。表尾结点的地址部分原来保存的是空地址NULL，此时需将其设置为新增结点的地址（即原表尾结点指向新增结点），然后将新增结点的地址部分设置为空地址NULL，即新增结点成为表尾。
   - 由于一般情况下链表只有一个头指针head，所以要在末尾添加结点就需要从头指针head开始逐个检查，直到找到最后一个结点（即表尾）。
   1. 首先分配内存空间，保存新增的结点。
   2. 从头指针head开始逐个检查，直到找到最后一个结点（即表尾）。
   3. 将表尾结点的地址设置为新增结点的地址。
   4. 将新增结点的地址部分设置为空地址NULL，即新增结点成为表尾。
3. 插入头结点
   插入头结点就是在链表首部添加结点的过程。
   1. 首先分配内存空间，保存新增的结点。
   2. 使新增结点指向头指针head所指向的结点。
   3. 然后使头指针head指向新增结点。
4. 查找结点
   查找结点就是在链表结构中查找需要的元素。对于链表结构来说，一般可通过关键字进行查询。
5. 插入结点
   插入结点就是在链表中间部分的指定位置增加一个结点。
   1. 首先分配内存空间，保存新增的结点。
   2. 找到要插入的逻辑位置，也就是位于哪两个结点之间。
   3. 修改插入位置结点的指针，使其指向新增结点，而使新增结点指向原插入位置所指向的结点。
6. 删除结点
   1. 查找需要删除的结点。
   2. 使前一结点指向当前结点的下一结点。
   3. 删除结点。
7. 计算链表长度
   计算链表长度也就是统计链表结构中结点的数量。顺序表中计算链表长度比较方便，但是在链表中计算链表长度稍微复杂一些，因为链表结构在物理上并不是连续存储的，因此需要遍历整个链表来对结点数量进行累加才能得到。
8. 显示所有结点
   显示所有结点数据并不是一个数据结构基本的运算，因为它可以简单地逐个引用结点来实现。程序中通过while循环来遍历整个链表，从而输出各个结点数据。