# 排序算法
Author & Note ：影风远sinkfarli

Create Date ：2022.6.18

排序算法是各类算法中最基本、最简单的一类算法。

## Content
- [Content](#content)
- [Chapter 1 排序算法概述](#chapter-1-排序算法概述)
- [Chapter 2 冒泡排序法](#chapter-2-冒泡排序法)
  - [2.1　冒泡排序算法](#21冒泡排序算法)
- [Chapter 3 选择排序法](#chapter-3-选择排序法)
  - [3.1　选择排序算法](#31选择排序算法)
- [Chapter 4 插入排序法](#chapter-4-插入排序法)
  - [4.1　插入排序算法](#41插入排序算法)
- [Chapter 5 Shell排序法](#chapter-5-shell排序法)
  - [5.1　Shell排序算法](#51shell排序算法)
- [Chapter 6　快速排序法](#chapter-6快速排序法)
  - [快速排序算法](#快速排序算法)
- [Chapter 7　堆排序法](#chapter-7堆排序法)
  - [7.1　堆排序算法](#71堆排序算法)
    - [7.1.1 堆结构](#711-堆结构)
  - [7.1.2 堆排序过程](#712-堆排序过程)
- [Chapter 8 合并排序法](#chapter-8-合并排序法)
  - [8.1　合并排序算法](#81合并排序算法)
- [Chapter 9　排序算法的效率](#chapter-9排序算法的效率)

## Chapter 1 排序算法概述
排序（Sort）是将一组数据按照一定的规则进行排列，一般按递增或递减的顺序进行排列。排序算法是一种最基本的算法。排序虽然看似是一个很简单的问题，但是在实际的应用场合往往面临一些困难。这是因为实际应用中的数据量往往很庞大，这样算法的效率和排序的速度是关键。需要根据合适的问题寻找一个适合高效的排序算法，因此便演变出了多种排序算法。

- 基本排序法
  1. 交换排序
     1. 冒泡排序法
     2. 快速排序法
  2. 选择排序
     1. 选择排序法
     2. 堆排序法
  3. 插入排序
     1. 插入排序法
     2. Shell排序法
  4. 合并排序

- 多路归并排序

每种排序算法都有各自的特点，某种算法在某些特定的场合具有比较好的执行效率。

在实际应用中，排序的对象基本是整数，基本排序规则包括从小到大排序和从大到小排序。



## Chapter 2 冒泡排序法
冒泡排序法（Bubble Sort）是所有排序算法中最简单、最基本的一种。冒泡排序法的思路就是交换排序，通过相邻数据的比较交换来达到排序的目的。

### 2.1　冒泡排序算法
冒泡排序算法通过多次比较和交换来实现排序，其排序流程如下：
1. 数组中的各数据，依次比较相邻的两个元素的大小。
2. 如果前面的数据大于后面的数据，就交换这两个数据。经过第一轮的多次比较排序后，便可把最小的数据排好。
3. 再用同样的方法把剩下的数据逐个进行比较，最后便可按照从小到大的顺序排好数组中各数据的顺序。


## Chapter 3 选择排序法
选择排序法（Selection Sort）也是比较简单的排序算法，思路比较直观。选择排序算法在每一步中选取最小值来重新排列，从而达到排序的目的。

### 3.1　选择排序算法
选择排序算法通过选择和交换来实现排序，其排序基本流程如下：
1. 首先从原始数组中选择一个最小的数据，将其和位于第1个位置的数据交换。
2. 从剩下的n-1个数据中选择次小的一个元素，将其和位于第2个位置的数据交换。
3. 这样不断重复，直到最后两个数据完成交换。最后，完成对原始数组从小到大的排序。



## Chapter 4 插入排序法
插入排序法（Insertion Sort）通过对未排序的数据逐个插入合适的位置而完成排序工作。插入排序算法的思路也比较简单，使用得也比较多。

### 4.1　插入排序算法
插入排序算法通过比较和插入来实现排序，其排序流程如下：
1. 首先对数组的前两个数据进行从小到大排序。
2. 将第3个数据与排好序的两个数据比较，将第3个数据插入合适的位置。
3. 将第4个数据插入已排好序的前3个数据中。
4. 不断重复上述过程，直到把最后一个数据插入合适的位置。最后便完成了对原始数组从小到大的排序。


## Chapter 5 Shell排序法
前面介绍的冒泡排序算法、选择排序算法和插入排序算法的思路都比较直观，但是排序的效率都比较低。对于遇到大量的数据需要排序时，往往需要寻求其他更为高效的排序算法，Shell排序算法便是其中一种。

### 5.1　Shell排序算法
Shell排序算法严格来说是基于插入排序的思想，又称为希尔排序或缩小增量排序。Shell排序算法的排序流程如下：
1. 将有n个元素的数组分成n/2个数字序列，第1个数据和第n/2+1个数据为一对，等等，依此类推。
2. 一次循环使每一个序列对排好顺序。
3. 变为n/4个序列，再次排序。（4）不断重复上述过程，随着序列减少直至最后变为1个，完成整个排序。



## Chapter 6　快速排序法
快速排序法（Quick Sort）和冒泡排序法类似，都是基于交换排序思想。但是快速排序对冒泡排序法进行了改进，从而使其具有更高的执行效率。

### 快速排序算法
通过多次比较和交换来实现排序，其排序流程如下：
1. 首先设定一个分界值，通过该分界值将数组分成左右两部分。
2. 将大于或等于分界值的数据集中到数组右边，小于分界值的数据集中到数组的左边。此时，左边部分中各元素都小于或等于分界值，而右边部分中各元素都大于或等于分界值。
3. 左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。
4. 重复上述过程，可以看出这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左、右两个部分各数据排序完成后，整个数组的排序也就完成了。


## Chapter 7　堆排序法
堆排序法（Heap Sort）是基于选择排序思想，利用堆结构和二叉树的一些性质来完成数据的排序。堆排序算法在一些场合具有很广泛的应用。

### 7.1　堆排序算法
相对于前面几种排序算法，堆排序比较新颖，涉及的概念比较多。下面介绍堆结构的概念和堆排序的过程和算法实现。

#### 7.1.1 堆结构
堆排序的关键是构造堆结构。堆结构是一种树结构，准确地说是一个完全二叉树。在这个树中每个结点对应原始数据的一个记录，并且每个结点应满足以下条件：
- 如果按照从小到大的顺序排序，要求非叶结点的数据要大于或等于其左、右子结点的数据。
- 如果按照从大到小的顺序排序，要求非叶结点的数据要小于或等于其左、右子结点的数据。下面以从小到大的顺序进行排序为例进行介绍。

从堆结构的定义可以看出，对结点的左子结点和右子结点的大小没有要求，只规定父结点和子结点数据之间必须满足的大小关系。这样，如果要求按照从小到大的顺序输出数据时，则堆结构的根结点为要求的最大值。


### 7.1.2 堆排序过程
一个完整的堆排序需要反复经过两个步骤：构造堆结构和堆排序输出。下面介绍如何构造堆结构。

构造堆结构就是把原始的无序数据按前面堆结构的定义进行调整。需要将原始的无序数据放置到一个完全二叉树的各个结点中，可以按照前面介绍的方法来实现。

由完全二叉树的下层向上层逐层对父子结点的数据进行比较，使父结点的数据大于子结点的数据。这里需要使用筛运算进行结点数据的调整，直到使所有结点最后满足堆结构的条件为止。筛运算主要针对非叶结点进行调整。

例如，对于一个非叶结点Ai，这里假定Ai的左子树和右子树均已进行筛运算，也就是说其左子树和右子树均已构成堆结构。对Ai进行筛运算，操作步骤如下：
1. 比较Ai的左子树和右子树的最大值，将最大值放在Aj中。
2. 将Ai的数据与Aj的数据进行比较，如果Ai大于等于Aj，表示以Ai为根的子树已构成堆结构，可以终止筛运算。
3. 如果Ai小于Aj，则将Ai与Aj互换位置。
4. 经过第 3 步后，可能会破坏以Ai为根的堆，因为此时Ai的值为原来的Aj。

下面以Aj为根重复前面的步骤，直到满足堆结构的定义，也就是父结点数据大于子结点。这样，以Aj为根的子树被调整为一个堆结构。

在执行筛运算时，值较小的数据将被逐层下移。


## Chapter 8 合并排序法
合并排序法（Merge Sort）就是将多个有序数据表合并成一个有序数据表。如果参与合并的只有两个有序表，称为二路合并。对于一个原始的待排序序列，往往可以通过分割的方法来归结为多路合并排序。这里以二路合并为例来介绍实现合并排序的算法。

### 8.1　合并排序算法
一个待排序的原始数据序列进行合并排序的基本思路如下：首先将含有n个结点的待排序数据序列看作有n个长度为1的有序子表组成，将它们依次两两合并，得到长度为2的若干有序子表；然后，再对这些子表进行两两合并，得到长度为4的若干有序子表，重复上述过程，直到最后的子表长度为n，从而完成排序过程。


## Chapter 9　排序算法的效率
排序算法有很多种，每种算法都有其优缺点，可以适应不同场合的需要。速度是决定排序算法最主要的因素，它是排序效率的一个重要指标。一般来说，可从以下几方面判断一个排序算法的优劣。

计算的复杂度：为了全面考虑，往往以最差、平均和最好3种情况进行评价。

系统资源的占用：主要包括内存以及其他资源的占用。一个好的排序算法应该尽量占用较少的内存资源。在本章介绍的排序算法中，大部分排序算法都只需要使用1个元素的存储单元，用来交换数据。而合并排序算法需使用与原始序列一样长的n个元素的存储单元，用来保存多遍合并操作。因此，合并排序算法占用的系统资源较大。

对于计算的复杂度，一般依据排序数据量的大小n来度量，主要表征了算法执行速度。这是算法优劣的一个重要指标。对于前面介绍的几种排序算法，其相应的计算复杂度排列如下：
- 冒泡排序法：平均速度为O（n2），最坏情况下的速度为O（n2）。
- 快速排序法：平均速度为O（nlogn），最坏情况下的速度为O（n2）。
- 选择排序法：平均速度O（n2），最坏情况下的速度为O（n2）。
- 堆排序法：平均速度为O（nlogn），最坏情况下的速度为O（nlogn）。
- 插入排序法：平均速度为O（n2），最坏情况下的速度为O（n2）。
- Shell排序法：平均速度为O（n3/2），最坏情况下的速度为O（n2）。
- 合并排序法：平均速度为O（nlogn），最坏情况下的速度为O（nlogn）。

没有某一种排序算法是绝对最好的，不同的排序算法各有优劣。在实际应用中，需要根据实际问题来选择合适的排序算法。
